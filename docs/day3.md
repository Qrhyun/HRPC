## 优化部分

### 通信模块

高效序列化/反序列化：目前算是实现。
网络传输：目前支持TCP，也就是Socket。
**连接池：没做，可以借鉴优秀的设计思路。
压缩与加密：支持数据压缩和传输加密TLS/SSL(但这里其实不使用HTTP2协议其实不去实现也行)。

### 服务注册与发现模块

支持动态扩展，通过服务注册中心(如Consul、zookeeper)实现服务发现和负载均衡。
健康检测：实时监测服务节点是否存货，及时剔除故障节点(这个很有实现的必要)。

### 负载均衡模块

负载均衡算法：支持多种策略：轮询，一致性哈希（建议先实现轮询）

### 高效线程/写成模型

以轻量级的协程替代线程模型

### 长连接

这个已经实现模拟，但感觉还是引入连接池更好。
### 零拷贝优化技术：
数据传输采用零拷贝，避免多次内存拷贝以提升吞吐量(如mmap和sendfile)

### 日志与监控模块
这个项目只是简单的引I入了日志库，但是并没有监控模块，比如监控QPS、延迟等。
### 健康检测与熔断机制
健康检查：定期ping服务节点或执行自定义检查逻辑。
熔断器：防止故障扩散，避免某些服务器超载。
降级机制：在服务器不可用时返回兜底数据(默认值或缓存值)。
### 重试与超时处理
超时控制：这一块没做，可以补充补充。
异常重试：如果连接失败会进行三次重试，在本项目中实现了。

## 问题

### 1.简单描述项目，实现了怎样的功能？用了什么？

- 这个项目是基于C++语言实现的一个RPC分布式网络通信框架项目，使用CMake在Linux平台上构建编译环境。它可以将任何单体架构系统的本地方法调用重构为基于TCP网络通信的RPC远程方法调用。该框架实现了同一台机器不同进程之间或不同机器之间服务用。它适用于将单体架构系统拆分为基于分布式微服务调用的部署。
- 网络层采用了高并发的`Reactor`网络模型`muduo`开源网络库实现。这使得**网络IO层和RPC方法调用处理层**进行代码解耦变得更加容易，并且具有良好的并发性能。RPC方法调用使用了`protobuf`进行相关数据的序列化和反序列化，`zookeeper`提供了服务器的注册和发现。

### 2.为什么要使用Zookeeper作为服务器注册与发现中心?
Zookeeper是一个分布式协调工具，特别适用于分布式环境中的服务注册与发现。它的优点是高可用性和一致性，通过Wathcer机制可以实时感知服务的上线和下线。Zookeeper使用ZAB协议保证数据的一致性，确保每个节点的数据更新都说线性化的。不过，它的缺点是：对于写操作吞吐量不高，可能会成为拼接，尤其在大规模集群中。

### 3.消息传输为什么用protobuf,而不用json？

protobuf主要是二进制的序列化数据，json主要是纯文本

- 占用空间：首先Json协议是典型的`Key-Value`明文协议，用起来相当方便，但是用`Json`序列化后的空间开销比较大，性能不行。
- Hsessian是动态类型、二进制、紧凑的、可跨语言移植的一种序列化框架，序列化后的二进制数据比Json紧凑高效。
- Protobuf序列化**体积**比JSON和Hession小很多，**序列化和反序列化速度也很快**，消息格式升级，**跨平台兼容性**也不错

### 4.在实现RPC服务时遇到了哪些难点？你是如何解决的

- 沾包/拆包问题：通过**自定义通信协议(消息头+消息体)解决，确保数据完整性。**

- zookeeper

  > + 学习Wathcher机制，**监听节点变化，实现动态服务注册与发现**。
  > + 将Zookeeper作为注册中序，提供高可用性和**实时更新**能力。

+ Protobuf的序列化和反序列化：熟悉Protobuf的定义文件、编译工具和API使用，确保高效传输数据。
+ 高并发网络处理：通过Muduo网络库提供事件循环与线程池，实现高性能并发。

### 5.如何处理分布式系统中的故障？你在项目中采取了哪些措施确保系统的高可用性？
在分布式系统中，故障不可避免，所以高可用性设计非常重要。我在项目中使用了如下措施：

+ 服务注册与发现：通过Zookeeper实现服务的动态注册与发现，**当某个服务宕机时，客户端可以自动从Zookeeper获取新的服务节点信息**
+ 超时重试：**客户端调用服务时**设置超时，如果服务未响应，则会重试一定次数。
+ 负载均衡：使用负载均衡策略，保证**请求均匀分配到多个服务实例上**，避免单点故障。
+ 故障熔断与降级：当某个服务连续失败时，**启动熔断机制**，**停止调用该服务**，避免影响整个系统。

### 6.为什么选择Glog作为日志库？它有哪些优点？
1.高性能：Glog支持**异步输出**，性能消耗较低，适合高并发场景。
2.线程安全：在**多线程**环境下保证日志写入的安全性，避免日志冲突。
3.日志等级分类：支持不同级别日志(INFO、WARNING、ERROR、FATAL)，开发者可以通过等级快速定位问题。
4.自动分割日志：支持**按大小或日期**进行日志文件分割，方便日志管理。
5.崩溃记录：在程序崩溃时可以生成堆栈信息，帮助诊断问题。

### 7.请简要解释一下RPC（远程过程调用）是什么，它是如何工作的？

Rpc是一种通过网络从远程计算机请求服务的协议。它的核心思想是，客户端通过代理调用服务端的方法，像调用本地方法一样，透明的隐藏了网络通信的细节。RPC的工作过程通常包括：
1.客户端发起请求，调用服务端的代理，序列化请求数据
2.通过网络传输到服务端。
3.服务端通过客户端的代理，进行反序列化数据。
4.处理请求方法生成响应，在通过客户端代理序列化返回客户端。

### 8.你如何看待微服务架构与传统单体应用架构的区别？

微服务架构通过将一个大型应用拆分为多个独立、自治的服务，能够提升系统的灵活性、可扩展性和可维护性。微服务算是分布式应用的一个重要基础，相较于传统单体架构，微服务具有以下优势：
1.独立部署与扩展：每个服务都可以独立部署，单个服务出现故障，并不会影响整个系统。
2.高可用性：服务之间的低耦合涉及，使得服务出现故障时可以快速的隔离。
3.技术栈的灵活：不同服务可以使用不同的技术栈，适应各自业务的需求。
但微服务架构也带来了一些挑战，如服务间通信、分布式事务处理和数据一致性等问题。

### 9.TCP粘包与拆包问题解决方案

`TCP黏包`

> TCP是流式协议，数据是按字节流传输的，没有明确的消息边界可能会导致：
>
> 应用层会发送数据过于频繁或者来不及接收：多个小包被TCP缓冲区合并，就会导致粘包。
>
> Nagle算法：Nagle算法**将小数据包合并后再发送**，进一步导致粘包。
>
> 例如：发送方连续发送两条消息msg1="hello"和 msg2="world"，接收方可能—次性接收到 helloworld。

`TCP拆包`

> 由于TCP传输是分段发送，可能出现以下情况：
>
> 消息过大：一条消息的长度超过TCP缓冲区的大小，分多个包传输。
>
> 网络拥塞或延迟：导致分包后不同时间接收到数据。

`解决`

> 通过自定义的协议和编码器/解码器，这一部分可以看看channel和provider(OnMessage)中如何做的。

### 10.Zookeeper的Watcher机制

- 在本项目中使用zookeeper是为了等到zookeeper客户端连接成功到服务端来通知，初始化成功，然后client客户端就可以从zookeeper的服务器上获取服务器对象和方法名
- watcher主要是来监视服务器的，如果服务端发生了什么变化就会通知客户端。不过你要想服务端通知客户端，客户端必须先往上面注册一个对某个节点的watch时间，服务端发给watch时间通知，但这个通知是不返回节点数据，知识通知客户端你要我监听的节点发生变化了，具体的处理逻辑可以通过捕获告知的时间类型进行相应的操作，但是Watcher时间只能用一次，可以后续永久递归watcher
- 客户端向服务端注册了watcher事件之外，还需要将这个watcher回调事件保存在watcherManager上，这样服务端通知就会通知watcherManager执行保存在watcherManmger的回调函数

### 11.MuduoReactor网络模型

### 12.自定义通信协议设计



